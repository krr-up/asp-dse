\documentclass[11pt]{beamer}
\usetheme{Warsaw}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{courier}
\usepackage{xcolor}
\usepackage{relsize}
\usepackage{tikz}
\usepackage{listings}

\newcommand{\Underscore}{\textscale{1}{\textunderscore}}
\author[Müller et al.]{Luise Müller and Kai Neubauer and Philipp Wanko}
\title[DSE with ASP: Progress and Outlook]{DSE with ASP: Progress and Outlook}
%\setbeamercovered{transparent} 
%\setbeamertemplate{navigation symbols}{} 
%\logo{} 
%\institute{} 
\date{} 
%\subject{} 

\begin{document}
\input{listings}
\input{systems}

\begin{frame}
\titlepage
\end{frame}

\section{Overview}

\begin{frame}{Overview}
\begin{itemize}
  \item Consolidated old work
  \item Reimplemented system with \clingo's application class
  \pause
  \item Currently working on experiments and writeup for \emph{Evolutionary System Design}
  \pause
  \item Collecting material and ideas for \emph{Generative Design Space Exploration}
\end{itemize}
\end{frame}

\section{Evolutionary System Design}

\begin{frame}{Problem Description}
  \begin{itemize}
    \item Given is an implementation of a specification
    \item Specification is modified
    \item Given new specification and legacy implementation, find implementations that are, first, Pareto-optimal and, second, close to the legacy implementation
  \end{itemize}
\end{frame}

\begin{frame}{Experimental Setup}
  \begin{enumerate}
    \item Find best-possible implementations to our benchmark set with a high timeout - currently running
    \item Select among the non-dominated implementations a random implementation - TODO
    \item Modify instance benchmark set to varying degrees - TODO
    \item Find implementations to new benchmarks with small timeout - TODO
    \item Employ strategies, optimization, domain-specific heuristic to find implementations to new benchmarks that are similar to legacy solution with same timeout as above - TODO
  \end{enumerate}
  \pause
  Expectation: We have faster convergence and smaller distance with similarity information, giving us high-quality solutions faster while being easier to produce.
\end{frame}

\begin{frame}{Strategies}
\end{frame}

\begin{frame}{Optimization}
\end{frame}

\begin{frame}{Heuristics}
\end{frame}

\section{Generative Design Space Exploration}

\begin{frame}{Problem Description}
  \begin{itemize}
    \item Architecture unknown prior to design process
    \item Instead of structure, we only have a set of hardware types (i.e., \textit{device library})
    \item As before, classified into processing and communication elements
    \item Mapping options assign tasks to processing \textit{types}, not to specific instances
    \item Topology of architecture is subject to exploration 
    \item Research questions:
    \begin{itemize}
      \item Can we define upper/lower bounds on the number of hardware types to instantiate?
      \item Should we constrain the topology? 
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Solution Approaches }
  Specification
  \begin{itemize} 
     \item Define processing types, e.g., \texttt{proc\_type(dsp). proc\_type(uC).}
     \item Define communication types, e.g., \texttt{comm\_type(router). comm\_type(bus).}
     \item Mapping options assign a task to a processing type, e.g., \texttt{map(m0, t1, dsp). map(m1, t1, uC).}
  \end{itemize}
\end{frame}

\begin{frame}{Solution Approaches (cntd.)}
    Allocation
  \begin{itemize} 
     \item Allocate number of instances
     \item Maximum number of instances per type must be constrained by upper bound
     \item an 'always safe' lower bound is zero
  \end{itemize}

  Binding
  \begin{itemize} 
     \item First, select type binding 
     \item Second, select specific instance for final binding
  \end{itemize}
\end{frame}

\begin{frame}{Solution Approaches (cntd.)}
  \label{slide:bounds}
  \begin{itemize} 
    \item Can we define upper/lower bounds on the number of hardware types to instantiate?
    \begin{itemize}
      \item General upper bound: number of processing element instances at most number of tasks \[\sum(instances)\leq \vert T\vert\]
      \item Specific upper bound: number of instances of a specific type at most number of mappings that contain that type \[\forall type: \sum(instance_{type}) \leq \sum(m)\mid m=(t, type)\]
      \item Lower bound: Only reliably decidable after type-binding
    \end{itemize}
    % \item Should we constrain the topology? 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Solution Approaches (cntd.)}
  \lstinputlisting[basicstyle=\tiny,breaklines=true]{alloc.lp}
  \pause
  4 Answer Sets:
  {\tiny
  \[\{\{(t_1,dsp_1),(t_2,dsp_1)\},\{(t_1,dsp_1),(t_2,dsp_2)\},\{(t_1,dsp_2),(t_2,dsp_1)\},\{(t_1,uC_1),(t_2,dsp_1)\}\}\]
  }
\end{frame}

\begin{frame}{Solution Approaches (cntd.)}
  
\end{frame}


\begin{frame}{Relevant Links}
\end{frame}

\begin{frame}{Switching schemes}
\end{frame}

\end{document}